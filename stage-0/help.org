#+TITLE: stage-0

Start with a Lisp language...
#+BEGIN_SRC elisp
(defun factorial (n)
   (if (= n 0) 1
       (* n (factorial (- n 1)))))
#+END_SRC

Moving the parens inwards gives:
#+BEGIN_SRC
defun(factorial n
 if( =(n 0) 1
    *(n factorial( -(n 1) ))))
#+END_SRC

And removing the keywords gives:
#+BEGIN_SRC
=>( factorial n
 ?( =(n 0) 1
    *(n factorial( -(n 1) ))))
#+END_SRC

And so:
#+BEGIN_SRC elisp
(defun factorial (n)
   (loop for i from 1 to n
         for value = 1 then (* value i)
         finally (return value)))
#+END_SRC

Becomes:
#+BEGIN_SRC
=>(factorial n :
    <-(value 1),
    #(i 1 +(n 1)
        <-(value *(value i))))
#+END_SRC

#+BEGIN_SRC ebnf
program    = expr END
expr       = term|term-list
term-list  = ':' expr+ ('.'|END))?.
term       = callable|scalar.
callable   = call|assignment|flow|operator.
call       = symbol '(' args ')'.
assignment = variable|function.
variable   = '<-' '(' symbol expr ')'.
function   = '=>' '(' symbol symbol* expr ')'.
operator   = (op-comp|op-math) "(" args ")".
op-comp    = '='|'<'|'>'
op-math    = '+'|'-'|'*'|'/'
flow       = flow-if|flow-for.
flow-if    = '?' '(' expr expr expr? ')'.
flow-for   = '#' '(' symbol expr expr expr ')'.
args       = expr*.
scalar     = symbol|digits.
digits     = /^\d+/.
symbol     = /^\w[\w\d]*/.
END        = (* End Of Input *)
#+END_SRC

** Basic Types
- true false       =boolean=
- 1 2 3 4 12,345   =integer=
- 1.0 1,200,433.65 =float=
- "string"         =string=
- variable-name    =reference=

** Structure Types
*** Lists [...]
[1 2 3]
[:a :b :c "abc" [1 2 3]]
*** Maps {...}
{"key1" "value1" 4 2}
*** Sets <...>
<"key1" "value1" 4 2>

** Function Calls
variable-name(arg1 arg2 arg3)

** Assignment
pi -> 3.14
3.14 <- pi
([args], body)

** Examples
factorial -> ( n
  if( =(n 0) 1
    *(n factorial( -(n 1) ))))
