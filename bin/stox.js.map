{"version":3,"sources":["../node_modules/.pnpm/opts@2.0.2/node_modules/opts/src/opts.js","../stox/src/cli-app.ts","../lib/stoa-ltk/language.ts","../lib/stoa-ltk/tokenizer.ts","../lib/stoa-ltk/parser.ts","../lib/stoa-ltk/reporter.ts","../lib/stoa-ltk/runtime.ts","../stox/src/tokenizer.ts","../stox/src/ast/visitor.ts","../stox/src/ast/expressions.ts","../stox/src/printer.ts","../stox/src/ast/declarations.ts","../stox/src/ast/nodes.ts","../stox/src/ast/statements.ts","../stox/src/parser.ts","../stox/src/resolver.ts","../stox/src/runtime/environment.ts","../stox/src/runtime/globals.ts","../stox/src/runtime/values.ts","../stox/src/runtime/control-flow.ts","../stox/src/interpreter.ts","../stox/src/stox-lang.ts","../lib/repl-kit/index.ts","../stox/src/repl.ts"],"sourcesContent":["/***************************************************************************\nAuthor   : Joey Mazzarelli\nEmail    : khtdr.com@gmail.com\nHomepage : http://khtdr.com/opts\nSource   : http://github.com/khtdr/opts.git\nLicense  : Simplified BSD License\n\nCopyright 2010 Joey Mazzarelli. All rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n   1. Redistributions of source code must retain the above copyright notice,\n      this list of conditions and the following disclaimer.\n\n   2. Redistributions in binary form must reproduce the above copyright notice,\n      this list of conditions and the following disclaimer in the documentation\n      and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY JOEY MAZZARELLI 'AS IS' AND ANY EXPRESS OR IMPLIED\nWARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\nEVENT SHALL JOEY MAZZARELLI OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\nINCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\nPROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\nLIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\nOR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\nADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\nThe views and conclusions contained in the software and documentation are those\nof the authors and should not be interpreted as representing official policies,\neither expressed or implied, of Joey Mazzarelli.\n***************************************************************************/\n\nvar puts        = console.log\n  , values      = {}\n  , args        = {}\n  , argv        = []\n  , errors      = []\n  , descriptors = {opts:[], args:[]};\n\n/**\n * Get some version info out of it\n */\nexports.version = '2.0.2';\n\n/**\n * Add a set of option descriptors, not yet ready to be parsed.\n * See exports.parse for description of options object\n *\n * Additionally, it takes a namespace as an argument, useful for\n * building options for a library in addition to the main app.\n */\nexports.add = function (options, namespace) {\n  for (var i=0; i<options.length; i++) {\n    options[i].namespace = namespace;\n    descriptors.opts.push(options[i]);\n  }\n};\n\n/**\n * Parse the command line options\n * @param array options  Options to parse\n * @param array args     Arguments to parse\n * @param bool  help     Automatically generate help message, default false\n *\n * ===== Options Docs =====\n * Each option in the array can have the following fields. None are required, \n * but you should at least provide a short or long name.\n *   {\n *     short       : 'l',\n *     long        : 'list',\n *     description : 'Show a list',\n *     value       : false,  // default false\n *     required    : true,   // default false\n *     callback    : function (value) { ... },\n *   }\n *\n * You can add an automatically generated help message by passing\n * a second parameter of <true> or by including the option;\n *   {\n *     long        : 'help',\n *     description : 'Show this help message',\n *     callback    : require('./opts').help,\n *   }\n *\n * ===== Arguments Docs =====\n * Arguments are different than options, and simpler. They typically come \n * after the options, but the library really doesn't care. Each argument\n * can have the form of:\n *   {\n *     name     : 'script',\n *     required : true,      // default false\n *     callback : function (value) { ... },\n *   }\n */\nexports.parse = function (options, params, help) {\n\n  if (params === true) {\n    help = true;\n    params = [];\n  } else if (!params) {\n    params = [];\n  } else {\n    for (var i=0; i<params.length; i++) {\n      descriptors.args.push(params[i]);\n    }\n  }\n\n  if (help) {\n    options.push({ long        : 'help'\n                 , description : 'Show this help message'\n                 , callback    : exports.help\n                 });\n  }\n  for (var i=0; i<options.length; i++) {\n    descriptors.opts.unshift(options[i]);\n  }\n  options = descriptors.opts;\n\n  var checkDup = function (opt, type) {\n    var prefix = (type == 'short')? '-': '--';\n    var name = opt[type];\n    if (!opts[prefix + name]) {\n      opts[prefix + name] = opt;\n    } else {\n      if (opt.namespace && !opts[prefix + opt.namespace + '.' + name]) {\n        opts[prefix + opt.namespace + '.' + name] = opt;\n        for (var i=0; i<descriptors.opts.length; i++) {\n          var desc = descriptors.opts[i];\n          if (desc.namespace == opt.namespace) {\n            if (type == 'long' && desc.long == opt.long) {\n                descriptors.opts[i].long = opt.namespace + '.' + opt.long;\n            } else if (type == 'short') {\n              delete descriptors.opts[i].short;\n            }\n          }\n        }\n      } else {\n        puts('Conflicting flags: ' + prefix + name + '\\n');\n        puts(helpString());\n        process.exit(1);\n      }\n    }\n  };\n\n  var opts = {};\n  for (var i=0; i<options.length; i++) {\n    if (options[i].short) checkDup(options[i], 'short');\n    if (options[i].long) checkDup(options[i], 'long');\n  }\n\n  for (var i=2; i<process.argv.length; i++) {\n    var inp = process.argv[i];\n    if (opts[inp]) {\n      // found a match, process it.\n      var opt = opts[inp];\n      if (!opt.value) {\n        if (opt.callback) opt.callback(true);\n        if (opt.short) values[opt.short] = true;\n        if (opt.long) values[opt.long] = true;\n      } else {\n        var next = process.argv[i+1];\n        if (!next || opts[next]) {\n          var flag = opt.short || opt.long;\n          errors.push('Missing value for option: ' + flag);\n          if (opt.short) values[opt.short] = true;\n          if (opt.long) values[opt.long] = true;\n        } else {\n          if (opt.callback) opt.callback(next);\n          if (opt.short) values[opt.short] = next;\n          if (opt.long) values[opt.long] = next;\n          i++;\n        }\n      }\n    } else {\n      // No match. If it starts with a dash, show an error. Otherwise\n      // add it to the extra params.\n      if (inp[0] == '-') {\n        puts('Unknown option: ' + inp);\n        if (opts['--help']) puts('Try --help');\n        process.exit(1);\n      } else {\n        argv.push(inp);\n        var arg = params.shift();\n        if (arg) {\n          args[arg.name] = inp;\n          if (arg.callback) arg.callback(inp);\n        }\n      }\n    }\n  }\n  for (var i=0; i<options.length; i++) {\n    var flag = options[i].short || options[i].long;\n    if (options[i].required && !exports.get(flag)) {\n      errors.push('Missing required option: ' + flag);\n    }\n  }\n  for (var i=0; i<params.length; i++) {\n    if (params[i].required && !args[params[i].name]) {\n      errors.push('Missing required argument: ' + params[i].name);\n    }\n  }\n  if (errors.length) {\n    for (var i=0; i<errors.length; i++) puts(errors[i]);\n    puts('\\n' + helpString());\n    process.exit(1);\n  }\n};\n\n/**\n * Get the value of an option. Can be the short or long option\n * @return string|true|undefined\n */\nexports.get = function (opt) {\n  return values[opt] || values['-' + opt] || values['--' + opt];\n};\n\n/**\n * Get all of the values after parsing. Can be short or long.\n * @return {[flag string] string|true}\n */\nexports.values = function () {\n  return Object.keys(values).reduce(\n    function(dict, name) {\n      name = name.replace('/^-+/', '');\n      dict[name] = exports.get(name);\n      return dict;\n    }, {}\n  );\n};\n\n/**\n * Get unknown args. Could have special meaning to client\n */\nexports.args = function () {\n  return argv;\n};\n\n/**\n * Get an arg by name.\n * This only works if arg names were passed into the parse function.\n * @param string name Name of arg\n * @return string Value of arg\n */\nexports.arg = function (name) {\n  //puts(require('sys').inspect(arguments));\n  return args[name];\n};\n\n/**\n * Print the help message and exit\n */\nexports.help = function () {\n  puts(helpString());\n  process.exit(0);\n};\n\n\n// Create the help string\nvar helpString = function () {\n  var exe = process.argv[0].split(require('path').sep).pop();\n  var file = process.argv[1].replace(process.cwd(), '.');\n  var str = 'Usage: ' + exe + ' ' + file;\n  if (descriptors.opts.length) str += ' [options]';\n  if (descriptors.args.length) {\n    for (var i=0; i<descriptors.args.length; i++) {\n      if (descriptors.args[i].required) {\n        str += ' ' + descriptors.args[i].name;\n      } else {\n        str += ' [' + descriptors.args[i].name + ']';\n      }\n    }\n  }\n  str += '\\n';\n  for (var i=0; i<descriptors.opts.length; i++) {\n    var opt = descriptors.opts[i];\n    if (opt.description) str += (opt.description) + '\\n';\n    var line = '';\n    if (opt.short && !opt.long) line += '-' + opt.short;\n    else if (opt.long && !opt.short) line += '--' + opt.long;\n    else line += '-' + opt.short + ', --' + opt.long;\n    if (opt.value) line += ' <value>';\n    if (opt.required) line += ' (required)';\n    str += '    ' + line + '\\n';\n  }\n  return str;\n};\n","import fs from \"fs\";\nimport opts from \"opts\";\nimport { StoxLang } from './stox-lang'\nimport { Repl } from './repl'\n\nopts.parse(\n    [\n        { short: \"r\", long: \"repl\", description: \"runs the repl\" },\n        { short: \"t\", long: \"tokens\", description: \"prints tokens and exits \" },\n        { short: \"p\", long: \"parse\", description: \"prints parse tree and exits \" },\n        {\n            short: \"v\",\n            long: \"version\",\n            description: \"prints version info and exits \",\n        },\n    ],\n    [{ name: \"file\" }],\n    true\n);\n\nconst Stox = new StoxLang();\nif (opts.get(\"version\")) {\n    console.log(`stox-${Stox.version}`);\n    process.exit(0);\n}\n\nconst tokenize = opts.get(\"tokens\"), parse = opts.get(\"parse\")\nconst stage = (tokenize && \"scan\") || (parse && \"parse\") || \"eval\";\nStox.options({ stage });\n\nif (opts.get('repl')) {\n    const repl = new Repl(Stox)\n    repl.run().finally(() => process.exit(0))\n\n} else {\n    const fileName = opts.arg(\"file\") ?? \"/dev/stdin\";\n    const sourceCode = fs.readFileSync(fileName).toString();\n    Stox.run(fileName, sourceCode);\n    process.exit(Stox.errored ? 1 : 0);\n}\n","import * as Lib from '.'\n\ntype RuntimeOpts = { stage: \"scan\" | \"parse\" | \"eval\" };\n\nexport abstract class Language<Tokens extends Lib.Lexicon, Ast extends object, Result> {\n    abstract readonly Tokenizer: typeof Lib.TokenStreamClass<Tokens>;\n    abstract readonly Parser: typeof Lib.Parser<Tokens, Ast>;\n    abstract readonly Resolver: typeof Lib.Visitor<Ast, void>;\n    abstract readonly Interpreter: typeof Lib.Visitor<Ast, Result>;\n    constructor(readonly reporter: Lib.Reporter = new Lib.StdErrReporter()) { }\n\n    private _interpreter?: Lib.Visitor<Ast, Result>\n    get interpreter() {\n        if (!this._interpreter)\n            this._interpreter = new this.Interpreter(this.reporter)\n        return this._interpreter\n    }\n\n    private _resolver?: Lib.Visitor<Ast, void>\n    get resolver() {\n        if (!this._resolver)\n            this._resolver = new this.Resolver(this.reporter, this.interpreter)\n        return this._resolver\n    }\n\n    private opts: RuntimeOpts = { stage: \"eval\" };\n    options(opts: RuntimeOpts) {\n        this.opts = opts;\n    }\n\n    public errored = false;\n    run(name: string, code: string) {\n        this.errored = false;\n        this.reporter.pushSource(name, code);\n        this.runToStage(code);\n        this.reporter.popSource();\n    }\n\n    private runToStage(source: string) {\n        const scanner = new this.Tokenizer(source, this.reporter);\n        const tokens = scanner.drain();\n        if (this.reporter.errors) {\n            this.errored = true;\n            this.reporter.tokenError();\n        }\n\n        if (this.opts.stage === \"scan\") {\n            scanner.print(tokens)\n            return;\n        }\n\n        const parser = new this.Parser(tokens, this.reporter);\n        const ast = parser.parse();\n        if (this.reporter.errors) {\n            this.errored = true;\n            this.reporter.parseError();\n            return;\n        }\n\n        if (!ast) return\n\n        this.resolver.visit(ast);\n        if (this.reporter.errors) {\n            this.errored = true;\n            this.reporter.parseError();\n            return;\n        }\n\n        if (this.opts.stage == \"parse\") {\n            parser.print(ast)\n            return;\n        }\n\n        this.interpreter.visit(ast);\n        if (this.reporter.errors) {\n            this.errored = true;\n            this.reporter.runtimeError();\n        }\n    }\n}\n","import * as Lib from \".\";\n\nexport type Lexeme = string | RegExp |\n    ((text: string, reporter: Lib.Reporter, line: number, column: number) => undefined | string);\nexport type Lexicon = Record<string, Lexeme>;\nconst ERROR_TOKEN = \"__stoa__::error\";\n\nexport class Token<Name = string> {\n    constructor(\n        readonly name: Name,\n        readonly text: string,\n        readonly pos: { line: number; column: number }\n    ) { }\n    toString() {\n        const pos = `[${this.pos.line},${this.pos.column}]`;\n        return `${this.name}${pos}`;\n    }\n}\n\nexport class TokenStream<Lx extends Lexicon> {\n    private generator: Generator<Token<keyof Lx>>;\n    constructor(\n        source: string,\n        lexicon: Lx,\n        readonly reporter: Lib.Reporter,\n        line = 1, column = 1\n    ) {\n        this.generator = tokenGenerator(source, lexicon, reporter, line, column);\n    }\n\n    private buffer: (Token<keyof Lx> | undefined)[] = [];\n    take(): Token<keyof Lx> | undefined {\n        this.peek();\n        return this.buffer.shift();\n    }\n    peek(): Token<keyof Lx> | undefined {\n        if (!this.buffer.length) this.buffer.push(this.next());\n        return this.buffer[0];\n    }\n    drain(): Token<keyof Lx>[] {\n        let token, tokens = [];\n        while ((token = this.take())) tokens.push(token);\n        return tokens;\n    }\n    print(tokens = this.buffer, level: 'error' | 'log' = 'log') {\n        console[level](tokens.map(t => `${t}`).join('\\n'))\n    }\n\n    private eof = false\n    private next(): Token<keyof Lx> | undefined {\n        if (this.eof) return\n        while (true) {\n            const token = this.generator.next().value;\n            if (!token) {\n                this.eof = true;\n                break;\n            }\n\n            if (token.name.toString().startsWith(\"_\")) continue;\n            if (token.name == ERROR_TOKEN) {\n                this.err(token);\n                continue;\n            }\n            return token;\n        }\n    }\n\n    public error = false;\n    private err(token: Token) {\n        this.error = true;\n        const { text, pos: { line, column } } = token;\n        this.reporter.error(\n            token,\n            `Syntax error near ${text} at ${line}:${column}`\n        );\n    }\n}\n\nexport class TokenStreamClass<Lx extends Lexicon> extends TokenStream<Lx> {\n    constructor(\n        source: string,\n        reporter: Lib.Reporter\n    ) { super(source, {} as Lx, reporter) }\n}\n\n\nfunction* tokenGenerator<Lx extends Lexicon>(\n    source: string,\n    lexicon: Lx,\n    reporter: Lib.Reporter,\n    start_line = 1, start_column = 1\n): Generator<Token<keyof Lx>> {\n    let idx = 0,\n        line = start_line,\n        column = start_column;\n    while (idx < source.length) {\n        const [name = ERROR_TOKEN, text = source[idx]] = longest(possible());\n        const token = new Token(name, text, pos());\n\n        const lines = text.split(\"\\n\").length;\n        if (lines > 1) {\n            line += lines - 1;\n            column = text.length - text.lastIndexOf(\"\\n\");\n        } else column += text.length;\n        idx += text.length;\n        yield token;\n    }\n\n    function pos() {\n        return { line: line, column: column };\n    }\n    function longest(candidates: [keyof Lx, string, boolean][]) {\n        if (!candidates.length) return [];\n        if (candidates.length == 1) return candidates[0];\n        return candidates.reduce((longest, current) => {\n            if (current[1].length > longest[1].length) return current\n            if (current[1].length == longest[1].length)\n                return !current[2] && longest[2] ? current : longest\n            return longest\n        });\n    }\n    function possible() {\n        const candidates: [keyof Lx, string, boolean][] = [];\n        Object.entries(lexicon).map(([name, rule]) => {\n            if (typeof rule == \"function\") {\n                const text = rule(source.substring(idx), reporter, line, column);\n                if (text !== undefined) candidates.push([name, text, false]);\n            } else if (typeof rule != \"string\") {\n                const dynamic = rule.source[rule.source.length - 1] == '*'\n                const regex = new RegExp(`^${rule.source}`, rule.flags);\n                const match = regex.exec(source.substring(idx));\n                if (match) return candidates.push([name, match[0], dynamic]);\n            } else if (source.substring(idx, idx + rule.length) == rule) {\n                return candidates.push([name, rule, false]);\n            }\n        });\n        return candidates;\n    }\n}\n\nexport const Tokens = {\n    STRINGS: {\n        STD: stringScanner\n    },\n    COMMENTS: {\n        SHEBANG: /\\#\\!\\/usr\\/bin\\/env\\s.*/,\n        DOUBLE_SLASH: /\\/\\/.*/,\n        C_STYLE: cStyleCommentScanner,\n    },\n    SPACE: {\n        ALL: /\\s+/,\n    }\n}\n\nfunction cStyleCommentScanner(value: string, reporter: Lib.Reporter, line: number, column: number) {\n    const tokenizer = new TokenStream(value, {\n        OPEN: \"/*\",\n        CLOSE: \"*/\",\n        ESCAPED_CHAR: /\\\\./,\n        CHAR: /.|\\s/,\n    }, reporter, line, column);\n    const opener = tokenizer.take();\n    if (opener && opener.name == \"OPEN\") {\n        let stack = 0,\n            closer: Lib.Token | undefined,\n            text = opener.text;\n        while ((closer = tokenizer.take())) {\n            text += closer.text;\n            if (closer.name == \"OPEN\") stack += 1;\n            else if (closer.name == \"CLOSE\") {\n                if (!stack) return text;\n                else stack -= 1;\n            }\n        }\n        reporter.error(opener, `Unclosed comment at line ${opener.pos.line}, column ${opener.pos.column}.`);\n        return text;\n    }\n}\n\nfunction stringScanner(value: string, reporter: Lib.Reporter, line: number, column: number) {\n    const tokenizer = new Lib.TokenStream(value, {\n        SINGLE: \"'\",\n        DOUBLE: '\"',\n        ESCAPED_CHAR: /\\\\./,\n        CHAR: /.|\\s/,\n    }, reporter, line, column);\n    const opener = tokenizer.take();\n    if (opener && [\"SINGLE\", \"DOUBLE\"].includes(opener.name)) {\n        let { text } = opener,\n            closer: Lib.Token | undefined;\n        while ((closer = tokenizer.take())) {\n            text += closer.text;\n            if (closer.name == opener.name) return text;\n        }\n        reporter.error(opener, `Unclosed string at line ${opener.pos.line}, column ${opener.pos.column}.`);\n        return text;\n    }\n}\n","import * as Lib from \".\";\n\nexport class Parser<Lx extends Lib.Lexicon, Ast extends object> {\n    constructor(\n        private readonly tokens: Lib.Token<keyof Lx>[],\n        protected reporter: Lib.Reporter = new Lib.StdErrReporter()\n    ) { }\n\n    parse(): Ast | undefined {\n        return undefined;\n    }\n    print(ast?: Ast, level: 'error' | 'log' = 'log') {\n        console[level](`${ast ?? ''}`)\n    }\n\n    private current = 0;\n\n    protected match(...names: string[]): boolean {\n        for (const name of names) {\n            if (this.check(name)) {\n                this.advance();\n                return true;\n            }\n        }\n        return false;\n    }\n\n    protected consume<Name extends keyof Lx>(name: Name, message: string): Lib.Token<Name> {\n        if (this.check(name)) return this.advance() as Lib.Token<typeof name>;\n        else throw `Error: ${this.peek()} ${message}`;\n    }\n\n    protected check(name: keyof Lx): boolean {\n        return this.peek()?.name == name;\n    }\n\n    protected atEnd(): boolean {\n        return !this.peek()?.name;\n    }\n\n    protected advance(): Lib.Token<keyof Lx> {\n        if (!this.atEnd()) this.current++;\n        return this.previous();\n    }\n\n    protected peek(ahead = 1): Lib.Token<keyof Lx> | undefined {\n        return this.tokens[this.current + (ahead - 1)];\n    }\n\n    protected previous<Name extends keyof Lx = keyof Lx>(): Lib.Token<Name> {\n        return this.tokens[this.current - 1] as Lib.Token<Name>;\n    }\n\n    protected error(token: Lib.Token, message = \"Unexpected token\") {\n        this.reporter.error(token, message);\n        return new ParseError(message);\n    }\n}\n\nexport class Visitor<Ast extends object, Result = string> {\n    constructor(\n        readonly reporter: Lib.Reporter = new Lib.StdErrReporter(),\n        readonly interpreter?: any\n    ) { }\n    visit(node: Ast): Result {\n        const name = node.constructor.name\n        const fn = this[name as keyof this]\n        if (typeof fn == 'function') return fn.bind(this)(node)\n        throw new ParseError(`Unvisitable node: ${name} (UNIMPLEMENTED BY AUTHOR)`)\n    }\n}\n\nexport class ParseError extends Error { }\n","import { Token } from \".\";\n\ntype Errors = [Token, string][]\n\nexport interface Reporter {\n    error(token: Token, message?: string): void\n    pushSource(name: string, source: string): void\n    popSource(): void\n    tokenError(): void\n    parseError(): void\n    runtimeError(): void\n    errors: false | [Token, string][]\n}\n\nexport class StdErrReporter implements Reporter {\n    private files: [string, string][] = []\n    pushSource(name: string, source: string) {\n        this.files.push([name, source])\n    }\n    popSource() {\n        this.files.pop()\n    }\n\n    private _errors: Errors = []\n    error(token: Token, message: string) {\n        this._errors.push([token, message])\n    }\n    get errors(): false | Errors {\n        return !this._errors.length ? false : this._errors\n    }\n\n    tokenError() { this.reportErrors('Token') }\n    parseError() { this.reportErrors('Parse') }\n    runtimeError() { this.reportErrors('Runtime') }\n    private reportErrors(type: string) {\n        const [name, source] = this.files[this.files.length - 1]\n        const lines = source.split(\"\\n\")\n        for (const [token, message] of this._errors) {\n            this.log(`${type} error in ${name} at line,col ${token.pos.line},${token.pos.column}`)\n            const prefix = `${token.pos.line}. `\n            const code = `${lines[token.pos.line - 1]}`\n            this.log(`${prefix}${code}`)\n            const spaces = `${prefix}${code}`.replace(/./g, ' ')\n            const arr = spaces.substring(0, prefix.length + token.pos.column - 1)\n            this.log(`${arr}â†‘`)\n            this.log(`${message}`)\n        }\n        this._errors = []\n    }\n\n    protected log(message: string) {\n        console.error(message)\n    }\n}\n","import { Token } from \"./tokenizer\";\n\nexport class RuntimeError extends Error {\n    constructor(readonly token: Token, message: string) {\n        super(message)\n    }\n}\n","import * as Ltk from \"stoa-ltk\";\n\nexport class Tokenizer extends Ltk.TokenStream<typeof Tokenizer.lexicon> {\n        static readonly lexicon = {\n                // literals\n                FALSE: /false/i,\n                NIL: /nil/,\n                NUMBER: /\\d+(\\.\\d+)?/,\n                STRING: Ltk.Tokens.STRINGS.STD,\n                TRUE: /true/i,\n                IDENTIFIER: /[a-z][a-z\\d]*/i,\n\n                // operators\n                AND: /and/i,\n                BANG: \"!\",\n                BANG_EQUAL: \"!=\",\n                DASH: \"-\",\n                EQUAL: \"=\",\n                EQUAL_EQUAL: \"==\",\n                GREATER: \">\",\n                GREATER_EQUAL: \">=\",\n                LESS: \"<\",\n                LESS_EQUAL: \"<=\",\n                NOT: /not/i,\n                OR: /or/i,\n                PLUS: \"+\",\n                SLASH: \"/\",\n                STAR: \"*\",\n\n                // puncuation\n                COLON: \":\",\n                COMMA: \",\",\n                DOT: \".\",\n                LEFT_CURL: \"{\",\n                LEFT_PAREN: \"(\",\n                QUESTION: \"?\",\n                RIGHT_CURL: \"}\",\n                RIGHT_PAREN: \")\",\n                SEMICOLON: \";\",\n\n                // keywords\n                BREAK: /break/i,\n                CLASS: /class/i,\n                CONTINUE: /continue/i,\n                ELSE: /else/i,\n                FOR: /for/i,\n                FUN: /fun/i,\n                IF: /if/i,\n                PRINT: /print/i,\n                RETURN: /return/i,\n                SUPER: /super/i,\n                THIS: /this/i,\n                VAR: /var/i,\n                WHILE: /while/i,\n\n                // discarded\n                _SHEBANG_COMMENT: Ltk.Tokens.COMMENTS.SHEBANG,\n                _MULTI_LINE_COMMENT: Ltk.Tokens.COMMENTS.C_STYLE,\n                _SINGLE_LINE_COMMENT: Ltk.Tokens.COMMENTS.DOUBLE_SLASH,\n                _SPACE: Ltk.Tokens.SPACE.ALL,\n        };\n\n        constructor(source: string, reporter: Ltk.Reporter) {\n                super(source, Tokenizer.lexicon, reporter);\n        }\n}\n\nexport type Lexicon = typeof Tokenizer.lexicon;\ntype TokenName = keyof typeof Tokenizer.lexicon;\n\nexport const TOKEN = (Object.keys(Tokenizer.lexicon) as TokenName[]).reduce(\n        (a, c) => ((a[c] = c), a),\n        {} as Record<string, string>\n) as { [key in TokenName]: key };\n\nexport type Token<T extends TokenName = TokenName> = Ltk.Token<T>;\n","import * as Ltk from 'stoa-ltk'\nimport type * as Decl from './declarations'\nimport type * as Expr from './expressions'\nimport type * as Node from './nodes'\nimport type * as Stmt from './statements'\n\nexport abstract class Visitor<Result = void> extends Ltk.Visitor<Node.Ast, Result> {\n    abstract AssignExpr(expr: Expr.AssignExpr): Result\n    abstract BinaryExpr(expr: Expr.BinaryExpr): Result\n    abstract BlockStmt(stmt: Stmt.BlockStmt): Result\n    abstract CallExpr(expr: Expr.CallExpr): Result\n    abstract ExpressionStmt(stmt: Stmt.ExpressionStmt): Result\n    abstract FunctionExpr(expr: Expr.FunctionExpr): Result\n    abstract FunctionDecl(decl: Decl.FunctionDecl): Result\n    abstract GroupExpr(expr: Expr.GroupExpr): Result\n    abstract IfStmt(stmt: Stmt.IfStmt): Result\n    abstract JumpStmt(stmt: Stmt.JumpStmt): Result\n    abstract LiteralExpr(expr: Expr.LiteralExpr): Result\n    abstract LogicalExpr(expr: Expr.LogicalExpr): Result\n    abstract PrintStmt(stmt: Stmt.PrintStmt): Result\n    abstract Program(program: Node.Program): Result\n    abstract ReturnStmt(stmt: Stmt.ReturnStmt): Result\n    abstract TernaryExpr(expr: Expr.TernaryExpr): Result\n    abstract UnaryExpr(expr: Expr.UnaryExpr): Result\n    abstract VariableDecl(decl: Decl.VariableDecl): Result\n    abstract VariableExpr(expr: Expr.VariableExpr): Result\n    abstract WhileStmt(stmt: Stmt.WhileStmt): Result\n}\n","import * as Node from './nodes'\nimport * as Stmt from './statements'\n\nexport class AssignExpr implements Node.Expression {\n    constructor(\n        readonly name: Node.Token<'IDENTIFIER'>,\n        readonly value: Node.Expression\n    ) { }\n}\n\nexport class BinaryExpr implements Node.Expression {\n    constructor(\n        readonly left: Node.Expression,\n        readonly operator: Node.Token,\n        readonly right: Node.Expression\n    ) { }\n}\n\nexport class CallExpr implements Node.Expression {\n    constructor(\n        readonly callee: Node.Expression,\n        readonly args: Node.Expression[],\n        readonly end: Node.Token<any>,\n    ) { }\n}\n\nexport class FunctionExpr implements Node.Expression {\n    constructor(\n        readonly params: Node.Token<\"IDENTIFIER\">[],\n        readonly block: Stmt.BlockStmt\n    ) { }\n}\n\nexport class GroupExpr implements Node.Expression {\n    constructor(\n        readonly inner: Node.Expression\n    ) { }\n}\n\nexport class LiteralExpr implements Node.Expression {\n    constructor(\n        readonly value: string | [number, number] | boolean | undefined | void\n    ) { }\n    toString() {\n        if (this.value === true || this.value === false) return `${this.value}`\n        if (this.value === undefined) return 'nil'\n        if (typeof this.value == 'string') return this.value\n        const [val, prec] = this.value\n        return `${val.toFixed(prec)}`\n    }\n}\n\nexport class LogicalExpr implements Node.Expression {\n    constructor(\n        readonly left: Node.Expression,\n        readonly operator: Node.Token<any>,\n        readonly right: Node.Expression\n    ) { }\n}\n\nexport class TernaryExpr implements Node.Expression {\n    constructor(\n        readonly left: Node.Expression,\n        readonly op1: Node.Token<any>,\n        readonly middle: Node.Expression,\n        readonly op2: Node.Token<any>,\n        readonly right: Node.Expression\n    ) { }\n}\n\nexport class UnaryExpr implements Node.Expression {\n    constructor(\n        readonly operator: Node.Token<any>,\n        readonly operand: Node.Expression\n    ) { }\n}\n\nexport class VariableExpr implements Node.Expression {\n    constructor(\n        readonly name: Node.Token<\"IDENTIFIER\">\n    ) { }\n}\n","import { Visitor } from './ast/visitor'\nimport * as Decl from './ast/declarations'\nimport * as Expr from './ast/expressions'\nimport * as Node from './ast/nodes'\nimport * as Stmt from './ast/statements'\n\nexport class Printer extends Visitor<string> {\n    AssignExpr(assign: Expr.AssignExpr): string {\n        return `(= ${assign.name.text} ${this.visit(assign.value)})`\n    }\n    BinaryExpr(expr: Expr.BinaryExpr): string {\n        const operator = expr.operator.text\n        const left = this.visit(expr.left)\n        const right = this.visit(expr.right)\n        return `(${operator} ${left} ${right})`\n    }\n    BlockStmt(block: Stmt.BlockStmt): string {\n        const blocks = block.statements.map(stmt => this.visit(stmt)).join(\"\\n\")\n        return `(block \\n${indent(blocks)}\\n)`\n    }\n    CallExpr(call: Expr.CallExpr): string {\n        const callee = `(call ${this.visit(call.callee)}`\n        if (!call.args.length) return `${callee})`\n        const args = call.args.map(arg => this.visit(arg)).join(' ')\n        return `${callee} ${args})`\n    }\n    ExpressionStmt(statement: Stmt.ExpressionStmt): string {\n        return this.visit(statement.expr)\n    }\n    FunctionExpr(fun: Expr.FunctionExpr): string {\n        const params = fun.params.map(p => p.text).join(' ')\n        const body = this.visit(fun.block)\n        return `(let [${params}] ${body})`\n    }\n    FunctionDecl(decl: Decl.FunctionDecl): string {\n        const name = decl.name.text\n        const val = this.visit(decl.func)\n        return `(fun ${name} ${val})`\n    }\n    GroupExpr(expr: Expr.GroupExpr): string {\n        const operand = this.visit(expr.inner)\n        return `(group ${operand})`\n    }\n    IfStmt(statement: Stmt.IfStmt): string {\n        const cond = this.visit(statement.condition)\n        const stmtTrue = this.visit(statement.trueStatement)\n        if (!statement.falseStatement) return `(if ${cond} ${stmtTrue})`\n        const stmtFalse = this.visit(statement.falseStatement)\n        return `(if ${cond} \\n${indent(stmtTrue)} \\n${indent(stmtFalse)})`\n    }\n    JumpStmt(statement: Stmt.JumpStmt): string {\n        const dest = statement.keyword.name\n        const dist = this.visit(statement.distance || new Expr.LiteralExpr([1, 0]))\n        return `(${dest} ${dist})`\n    }\n    LiteralExpr(expr: Expr.LiteralExpr): string {\n        return expr.toString()\n    }\n    LogicalExpr(expr: Expr.LogicalExpr): string {\n        return this.BinaryExpr(expr)\n    }\n    PrintStmt(statement: Stmt.PrintStmt): string {\n        return `(print ${this.visit(statement.expr)})`\n    }\n    Program(program: Node.Program): string {\n        const decls = program.code.map(decl => this.visit(decl)).join(\"\\n\")\n        return `(program \\n${indent(decls)}\\n)`\n    }\n    ReturnStmt(ret: Stmt.ReturnStmt): string {\n        return `(return ${this.visit(ret.expr)})`\n    }\n    TernaryExpr(expr: Expr.TernaryExpr): string {\n        const left = this.visit(expr.left)\n        const middle = this.visit(expr.middle)\n        const right = this.visit(expr.right)\n        return `(?: ${left} ${middle} ${right})`\n    }\n    UnaryExpr(expr: Expr.UnaryExpr): string {\n        const operator = expr.operator.text\n        const operand = this.visit(expr.operand)\n        return `(${operator} ${operand})`\n    }\n    VariableDecl(declaration: Decl.VariableDecl): string {\n        const decl = `(var ${declaration.name.text}`\n        const init = declaration.expr ? ` ${this.visit(declaration.expr)}` : ''\n        return `${decl}${init})`\n    }\n    VariableExpr(expr: Expr.VariableExpr): string {\n        return `${expr.name.text}`\n    }\n    WhileStmt(statement: Stmt.WhileStmt): string {\n        const cond = this.visit(statement.condition)\n        const body = this.visit(statement.body)\n        return `(while ${cond} \\n${indent(body)}\\n)`\n    }\n}\n\nfunction indent(text: string): string {\n    const pad = new Array(3).fill(' ').join('')\n    return text.replace(/^/mg, pad)\n}\n","import * as Expr from './expressions'\nimport * as Node from './nodes'\n\nexport class FunctionDecl implements Node.Declaration {\n    constructor(\n        readonly name: Node.Token<\"IDENTIFIER\">,\n        readonly func: Expr.FunctionExpr,\n    ) { }\n}\n\nexport class VariableDecl implements Node.Declaration {\n    constructor(\n        readonly name: Node.Token<\"IDENTIFIER\">,\n        readonly expr: Node.Expression | undefined\n    ) { }\n}\n","// usually identifiers and references for static analysis\nexport { TOKEN } from '../tokenizer'\nexport type { Token } from '../tokenizer'\n\n// Any node that can be visited by a parser, printer, resolver, etc.\nexport interface Ast { }\n\n// Nodes that setup side effects\nexport interface Declaration extends Ast { }\n\n// Nodes that runtime side effects\nexport interface Statement extends Ast { }\n\n// Nodes that can be expressed as a value\nexport interface Expression extends Ast { }\n\n// Root of AST\nexport class Program implements Ast {\n    constructor(\n        readonly code: Ast[]\n    ) { }\n}\n","import * as Node from './nodes'\n\nexport class BlockStmt implements Node.Statement {\n    constructor(\n        readonly statements: Node.Statement[]\n    ) { }\n}\n\nexport class ExpressionStmt implements Node.Statement {\n    constructor(\n        readonly expr: Node.Expression\n    ) { }\n}\n\nexport class IfStmt implements Node.Statement {\n    constructor(\n        readonly condition: Node.Expression,\n        readonly trueStatement: Node.Statement,\n        readonly falseStatement?: Node.Statement\n    ) { }\n}\n\nexport class JumpStmt implements Node.Statement {\n    constructor(\n        readonly keyword: Node.Token<'BREAK' | 'CONTINUE'>,\n        readonly distance: Node.Expression,\n    ) { }\n}\n\nexport class PrintStmt implements Node.Statement {\n    constructor(\n        readonly expr: Node.Expression\n    ) { }\n}\n\nexport class ReturnStmt implements Node.Statement {\n    constructor(\n        readonly expr: Node.Expression,\n        readonly keyword: Node.Token<'RETURN'>\n    ) { }\n}\n\nexport class WhileStmt implements Node.Statement {\n    constructor(\n        readonly condition: Node.Expression,\n        readonly body: Node.Statement\n    ) { }\n}\n","import * as Ltk from \"stoa-ltk\";\nimport { TOKEN } from \"./tokenizer\";\nimport { Printer } from \"./printer\";\nimport * as Decl from './ast/declarations'\nimport * as Expr from './ast/expressions'\nimport * as Node from './ast/nodes'\nimport * as Stmt from './ast/statements'\n\n\nexport class Parser extends Ltk.Parser<typeof TOKEN, Node.Ast> {\n    private _parsed?: Node.Ast;\n    parse() {\n        if (!this._parsed) this._parsed = this.Program();\n        return this._parsed;\n    }\n    toString() {\n        if (!this._parsed) return \"un-parsed\";\n        return new Printer().visit(this._parsed)\n    }\n    print(ast = this._parsed, level: 'error' | 'log' = 'log') {\n        const message = !ast ? \"()\" : new Printer().visit(ast)\n        console[level](message)\n    }\n\n    // program -> declaration* EOF\n    Program() {\n        const declarations: Node.Statement[] = []\n        while (!this.atEnd()) {\n            const decl = this.Declaration()\n            if (decl) declarations.push(decl)\n        }\n        return new Node.Program(declarations)\n    }\n\n    // declaration -> fun_declaration | var_declaration | statement\n    Declaration() {\n        try {\n            return this.FunDeclaration() || this.VarDeclaration() || this.Statement()\n        } catch (err) {\n            if (err instanceof Ltk.ParseError) {\n                this.synchronize()\n                return\n            } else throw err\n        }\n    }\n\n    // fun_declaration -> \"fun\" IDENTIFIER function \";\"\n    FunDeclaration(): Decl.FunctionDecl | void {\n        if (this.peek(1)?.name == TOKEN.FUN && this.peek(2)?.name == TOKEN.IDENTIFIER) {\n            this.match(TOKEN.FUN)\n            const ident = this.consume(\"IDENTIFIER\", \"Expected identifier\")\n            const fun = this.Function()\n            return new Decl.FunctionDecl(ident, fun)\n        }\n    }\n\n    // function -> \"(\" parameters? \")\" block\n    Function(): Expr.FunctionExpr {\n        this.consume(TOKEN.LEFT_PAREN, \"Expected (\")\n        const parameters = this.Parameters()\n        this.consume(TOKEN.RIGHT_PAREN, \"Expected )\")\n        const block = this.Block()\n        if (!block) throw this.error(this.peek()!, \"Expected {\")\n        return new Expr.FunctionExpr(parameters, block)\n    }\n\n    // parameters -> IDENTIFER (\",\" IDENTIFIER)*\n    Parameters(): Ltk.Token<\"IDENTIFIER\">[] {\n        const params: Ltk.Token<\"IDENTIFIER\">[] = []\n        if (this.peek()?.name != TOKEN.RIGHT_PAREN) {\n            if (params.length >= 255) this.error(this.peek()!, 'Too many params (255 max)')\n            do {\n                const id = this.consume(TOKEN.IDENTIFIER, 'expected param name')\n                params.push(id as Ltk.Token<'IDENTIFIER'>)\n            } while (this.peek()?.name == TOKEN.COMMA)\n        }\n        return params\n    }\n\n    // var_declaration -> \"var\" IDENTIFIER (\"=\" expression)? \";\"\n    VarDeclaration(): Decl.VariableDecl | void {\n        if (this.match(TOKEN.VAR)) {\n            const ident = this.consume(\"IDENTIFIER\", \"Expected identifier\")\n            let expr: Node.Expression | undefined\n            if (this.match(TOKEN.EQUAL)) {\n                expr = this.Expression()\n            }\n            this.consume(TOKEN.SEMICOLON, \"Expected ;\")\n            return new Decl.VariableDecl(ident, expr)\n        }\n    }\n\n    // statement -> return_statement | print_statement | if_statement | while_statement |\n    //              for_statement | jump_statement | block | expressiont_statement\n    Statement(): Node.Statement {\n        return this.PrintStatement() ||\n            this.ReturnStatement() ||\n            this.IfStatement() ||\n            this.WhileStatement() ||\n            this.ForStatement() ||\n            this.JumpStatement() ||\n            this.Block() ||\n            this.ExpressionStatement()\n    }\n\n    ReturnStatement(): Stmt.ReturnStmt | void {\n        if (this.match(TOKEN.RETURN)) {\n            const keyword = this.previous<'RETURN'>()\n            let expr: Node.Expression = new Expr.LiteralExpr(undefined)\n            if (!this.match(TOKEN.SEMICOLON)) {\n                expr = this.Expression()\n                this.consume(TOKEN.SEMICOLON, \"Expected ;\");\n            }\n            return new Stmt.ReturnStmt(expr, keyword)\n        }\n    }\n\n    // block -> \"{\" declaration* \"}\"\n    Block(): Stmt.BlockStmt | void {\n        if (this.match(TOKEN.LEFT_CURL)) {\n            const declarations: Node.Declaration[] = []\n            while (!this.atEnd() && this.peek()?.name != TOKEN.RIGHT_CURL) {\n                const decl = this.Declaration()\n                if (decl) declarations.push(decl)\n            }\n            const block = new Stmt.BlockStmt(declarations)\n            this.consume(TOKEN.RIGHT_CURL, 'Expected }')\n            return block\n        }\n    }\n\n    // jump_statement -> (\"break\" | \"continue\") expression? \";\"\n    JumpStatement(): Stmt.JumpStmt | void {\n        if (this.match(TOKEN.BREAK, TOKEN.CONTINUE)) {\n            const jump = this.previous<\"CONTINUE\" | \"BREAK\">()\n            let expr: Node.Expression = new Expr.LiteralExpr([1, 0])\n            if (this.peek()?.name != TOKEN.SEMICOLON)\n                expr = this.Expression()\n            this.consume(TOKEN.SEMICOLON, \"Expected ;\")\n            return new Stmt.JumpStmt(jump, expr);\n        }\n    }\n\n    // if_statement -> \"if\" \"(\" expression \")\" statement (\"else\" statement)?\n    IfStatement(): Stmt.IfStmt | void {\n        if (this.match(TOKEN.IF)) {\n            this.consume(TOKEN.LEFT_PAREN, \"Expected (\")\n            const cond = this.Expression()\n            this.consume(TOKEN.RIGHT_PAREN, \"Expected )\")\n            const trueStatement = this.Statement()\n            if (this.match(TOKEN.ELSE)) {\n                const falseStatement = this.Statement()\n                return new Stmt.IfStmt(cond, trueStatement, falseStatement)\n            } else {\n                return new Stmt.IfStmt(cond, trueStatement)\n            }\n        }\n    }\n\n    // while_statement -> \"while\" \"(\" expression \")\" statement\n    WhileStatement(): Stmt.WhileStmt | void {\n        if (this.match(TOKEN.WHILE)) {\n            this.consume(TOKEN.LEFT_PAREN, \"Expected (\")\n            const cond = this.Expression()\n            this.consume(TOKEN.RIGHT_PAREN, \"Expected )\")\n            const body = this.Statement()\n            return new Stmt.WhileStmt(cond, body)\n        }\n    }\n\n    // for_statement -> \"for\" \"(\" var_decl | exprStmt | \";\" expression? \";\" expression? \")\" statement\n    ForStatement(): Stmt.BlockStmt | void {\n        if (this.match(TOKEN.FOR)) {\n            this.consume(TOKEN.LEFT_PAREN, \"Expected (\")\n            const init = this.VarDeclaration() ||\n                this.ExpressionStatement() ||\n                (this.consume(TOKEN.SEMICOLON, \"Expected ;\") && new Expr.LiteralExpr(true))\n            let cond: Node.Expression = new Expr.LiteralExpr(true)\n            if (this.peek()?.name != TOKEN.SEMICOLON)\n                cond = this.Expression()\n            this.consume(TOKEN.SEMICOLON, \"Expected ;\")\n            let incr: Node.Expression = new Expr.LiteralExpr(true)\n            if (this.peek()?.name != TOKEN.RIGHT_PAREN)\n                incr = this.Expression()\n            this.consume(TOKEN.RIGHT_PAREN, \"Expected )\")\n            const body_statement = this.Statement()\n            return new Stmt.BlockStmt([\n                init,\n                new Stmt.WhileStmt(\n                    cond,\n                    new Stmt.BlockStmt([\n                        body_statement,\n                        new Stmt.ExpressionStmt(incr)\n                    ])\n                )\n            ])\n        }\n    }\n\n    // print_statement -> \"print\" expression \";\"\n    PrintStatement(): Stmt.PrintStmt | void {\n        if (this.match(TOKEN.PRINT)) {\n            const expr = this.Expression();\n            this.consume(TOKEN.SEMICOLON, \"Expected ;\")\n            return new Stmt.PrintStmt(expr);\n        }\n    }\n\n    // expression_statement -> expression \";\"\n    ExpressionStatement(): Stmt.ExpressionStmt {\n        const expr = this.Expression();\n        this.consume(TOKEN.SEMICOLON, \"Expected ;\")\n        return new Stmt.ExpressionStmt(expr);\n    }\n\n    // expression -> comma\n    Expression(): ReturnType<typeof this.Comma> {\n        return this.Comma();\n    }\n\n    // comma -> assignment (\",\" assignment)*\n    Comma(): ReturnType<typeof this.Assignment> | Expr.BinaryExpr {\n        let expr = this.Assignment();\n        while (this.match(TOKEN.COMMA)) {\n            const comma = this.previous();\n            const right = this.Assignment();\n            expr = new Expr.BinaryExpr(expr, comma, right);\n        }\n        return expr;\n    }\n\n    // assignment -> IDENTIFIER \"=\" assignment | logic_or\n    Assignment(): ReturnType<typeof this.LogicOr> | Expr.AssignExpr {\n        const expr = this.LogicOr()\n        if (this.match(TOKEN.EQUAL)) {\n            const eq = this.previous()\n            const value = this.Assignment()\n            if (expr instanceof Expr.VariableExpr) {\n                return new Expr.AssignExpr(expr.name, value)\n            }\n            this.error(eq, \"Invalid assignment target\")\n        }\n        return expr\n    }\n\n    // logic_or -> logic_and (\"or\" logic_and)*\n    LogicOr(): ReturnType<typeof this.LogicAnd> | Expr.LogicalExpr {\n        let expr = this.LogicAnd();\n        while (this.match(TOKEN.OR)) {\n            const or = this.previous();\n            const right = this.LogicAnd();\n            expr = new Expr.LogicalExpr(expr, or, right);\n        }\n        return expr;\n    }\n\n    // logic_and -> conditional (\"and\" conditional)*\n    LogicAnd(): ReturnType<typeof this.Conditional> | Expr.LogicalExpr {\n        let expr = this.Conditional();\n        while (this.match(TOKEN.AND)) {\n            const and = this.previous();\n            const right = this.Conditional();\n            expr = new Expr.LogicalExpr(expr, and, right);\n        }\n        return expr;\n    }\n\n    // conditional -> equality (\"?\" equality \":\" equality)*\n    Conditional(): ReturnType<typeof this.Equality> | Expr.TernaryExpr {\n        let expr: ReturnType<typeof this.Equality> | Expr.TernaryExpr = this.Equality();\n        while (this.match(TOKEN.QUESTION)) {\n            const question = this.previous();\n            const middle = this.Equality();\n            this.consume(TOKEN.COLON, \"Expected :\");\n            const colon = this.previous();\n            const right = this.Equality();\n            expr = new Expr.TernaryExpr(expr, question, middle, colon, right);\n        }\n        return expr;\n    }\n\n    // equality -> comparison ((\"!=\" | \"==\") comparison)*\n    Equality(): ReturnType<typeof this.Comparison> | Expr.BinaryExpr {\n        let expr = this.Comparison();\n        while (this.match(TOKEN.BANG_EQUAL, TOKEN.EQUAL_EQUAL)) {\n            const operator = this.previous();\n            const right = this.Comparison();\n            expr = new Expr.BinaryExpr(expr, operator, right);\n        }\n        return expr;\n    }\n\n    // comparison -> term ((\">\"|\"<\"|\"<=\"|\">=\") term)*\n    Comparison(): ReturnType<typeof this.Term> | Expr.BinaryExpr {\n        let expr = this.Term();\n        while (\n            this.match(\n                TOKEN.LESS,\n                TOKEN.GREATER,\n                TOKEN.LESS_EQUAL,\n                TOKEN.GREATER_EQUAL\n            )\n        ) {\n            const operator = this.previous();\n            const right = this.Term();\n            expr = new Expr.BinaryExpr(expr, operator, right);\n        }\n        return expr;\n    }\n\n    // term -> factor ((\"+\"|\"-\") factor)*\n    Term(): ReturnType<typeof this.Factor> | Expr.BinaryExpr {\n        let expr = this.Factor();\n        while (this.match(TOKEN.PLUS, TOKEN.DASH)) {\n            const operator = this.previous();\n            const right = this.Factor();\n            expr = new Expr.BinaryExpr(expr, operator, right);\n        }\n        return expr;\n    }\n\n    // factor -> unary ((\"*\"|\"/\") unary)*\n    Factor(): ReturnType<typeof this.Unary> | Expr.BinaryExpr {\n        let expr: ReturnType<typeof this.Unary> | Expr.BinaryExpr = this.Unary();\n        while (this.match(TOKEN.STAR, TOKEN.SLASH)) {\n            const operator = this.previous();\n            const right = this.Unary();\n            expr = new Expr.BinaryExpr(expr, operator, right);\n        }\n        return expr;\n    }\n\n    // unary -> _invalid_unary* _valid_unary\n    Unary(): ReturnType<typeof this._ValidUnary> {\n        while (this._InvalidUnary()) { }\n        return this._ValidUnary();\n    }\n\n    // _invalid_unary -> (\"+\" | \"*\" | \"/\") unary | e\n    private _InvalidUnary(): ReturnType<typeof this._ValidUnary> | undefined {\n        if (this.match(TOKEN.PLUS, TOKEN.STAR, TOKEN.SLASH)) {\n            this.reporter.error(\n                this.previous(),\n                \"Binary operator is missing the left operand\"\n            );\n            this.previous();\n            return this.Unary();\n        }\n        return;\n    }\n\n    // _valid_unary -> (\"!\" | \"-\") unary | call\n    private _ValidUnary(): Expr.UnaryExpr | ReturnType<typeof this.Call> {\n        if (this.match(TOKEN.BANG, TOKEN.DASH)) {\n            const operator = this.previous();\n            const right = this.Unary();\n            return new Expr.UnaryExpr(operator, right);\n        }\n        return this.Call();\n    }\n\n    // call -> primary (\"(\" (expression (\",\" expression)*)? \")\")*\n    Call(): ReturnType<typeof this.Primary> | Expr.CallExpr {\n        let expr: Expr.CallExpr | ReturnType<typeof this.Primary> = this.Primary();\n        if (!this.check(TOKEN.LEFT_PAREN)) return expr\n\n        while (true) {\n            if (!this.match(TOKEN.LEFT_PAREN)) break\n            const args: Node.Expression[] = []\n            if (!this.check(TOKEN.RIGHT_PAREN)) {\n                if (args.length >= 255) this.error(this.peek()!, 'Too many args (255 max)')\n                do {\n                    args.push(this.Expression())\n                } while (this.match(TOKEN.COMMA))\n            }\n            const paren = this.consume(TOKEN.RIGHT_PAREN, \"Expected ) after arguments\")\n            expr = new Expr.CallExpr(expr, args, paren)\n        }\n        return expr\n    }\n\n    // primary    -> IDENTIFIER | NUMBER | STRING | TRUE | FALSE | NIL | \"(\" expression \")\" | \"fun\" function\n    Primary(): Expr.LiteralExpr | Expr.VariableExpr | Expr.GroupExpr | Expr.FunctionExpr {\n        if (this.match(TOKEN.NUMBER)) {\n            const numStr = this.previous<'NUMBER'>().text\n            const value = parseFloat(numStr)\n            const precision = `${numStr}.`.split('.')[1].length\n            return new Expr.LiteralExpr([value, precision])\n        }\n        if (this.match(TOKEN.STRING)) {\n            const str = this.previous<'STRING'>().text\n            let value: string\n            if (['\"', \"'\"].includes(str.substring(str.length - 1)))\n                value = str.replace(/^.(.*).$/, \"$1\")\n            else\n                value = str.replace(/^.(.*)$/, \"$1\")\n            return new Expr.LiteralExpr(value);\n        }\n        if (this.match(TOKEN.TRUE)) {\n            return new Expr.LiteralExpr(true);\n        }\n        if (this.match(TOKEN.FALSE)) {\n            return new Expr.LiteralExpr(false);\n        }\n        if (this.match(TOKEN.NIL)) {\n            return new Expr.LiteralExpr(undefined);\n        }\n        if (this.match(TOKEN.IDENTIFIER)) {\n            return new Expr.VariableExpr(this.previous());\n        }\n        if (this.match(TOKEN.LEFT_PAREN)) {\n            const expr = this.Expression();\n            this.consume(TOKEN.RIGHT_PAREN, 'Expected \")\" after expression');\n            return new Expr.GroupExpr(expr);\n        }\n        if (this.match(TOKEN.FUN)) {\n            return this.Function()\n        }\n        throw `Expected expression at ${this.peek()}`;\n    }\n\n    synchronize() {\n        this.advance();\n        while (!this.atEnd()) {\n            if (this.previous().name == \"SEMICOLON\") return;\n            switch (this.peek()?.name ?? '') {\n                case \"CLASS\":\n                case \"FOR\":\n                case \"FUN\":\n                case \"IF\":\n                case \"PRINT\":\n                case \"RETURN\":\n                case \"VAR\":\n                case \"WHILE\":\n                    return;\n            }\n            this.advance();\n        }\n    }\n}\n","import * as Ltk from \"stoa-ltk\";\nimport { Interpreter } from \"./interpreter\";\nimport { Visitor } from \"./ast/visitor\";\nimport * as Decl from './ast/declarations'\nimport * as Expr from './ast/expressions'\nimport * as Node from './ast/nodes'\nimport * as Stmt from './ast/statements'\n\nenum FunctionType {\n    NONE,\n    FUNCTION,\n}\n\nenum VariableType {\n    DECLARED,\n    DEFINED,\n}\n\n/**\n * Lexical bindings and scope *   is static scope\n * which means static/semantic analysis and\n * an extra pass called \"Resolver\".\n *\n * And other static analysis checks.\n */\n\nexport class Resolver extends Visitor<void> {\n    constructor(\n        readonly reporter: Ltk.Reporter,\n        readonly evaluator: Interpreter\n    ) {\n        super();\n    }\n    private currentFunction = FunctionType.NONE;\n    private scopes: Record<string, VariableType>[] = [];\n    private beginScope() {\n        this.scopes.unshift({});\n    }\n    private endScope() {\n        this.scopes.shift();\n    }\n    private declare(ident: Ltk.Token<\"IDENTIFIER\">) {\n        const scope = this.scopes[0];\n        if (!scope) return;\n        if (scope[ident.text] === VariableType.DECLARED)\n            this.reporter.error(ident, \"Variable is already declared\");\n        if (scope[ident.text] === VariableType.DEFINED)\n            this.reporter.error(ident, \"Variable is already defined\");\n        scope[ident.text] = VariableType.DECLARED;\n    }\n    private define(ident: Ltk.Token<\"IDENTIFIER\">) {\n        const scope = this.scopes[0];\n        if (!scope) return;\n        scope[ident.text] = VariableType.DEFINED;\n    }\n    private resolveLocal(expr: Node.Expression, token: Ltk.Token<\"IDENTIFIER\">) {\n        this.scopes.find((scope, i) => {\n            if (scope[token.text]) {\n                this.evaluator.resolve(expr, i);\n                return true;\n            }\n            return false;\n        });\n    }\n    private resolveFunction(fun: Expr.FunctionExpr, ft: FunctionType) {\n        const encFunction = this.currentFunction;\n        this.currentFunction = ft;\n        this.beginScope();\n        for (const param of fun.params) {\n            this.declare(param);\n            this.define(param);\n        }\n        this.visit(fun.block);\n        this.endScope();\n        this.currentFunction = encFunction;\n    }\n\n    AssignExpr(expr: Expr.AssignExpr) {\n        this.visit(expr.value);\n        this.resolveLocal(expr, expr.name);\n    }\n    BinaryExpr(expr: Expr.BinaryExpr) {\n        this.visit(expr.left);\n        this.visit(expr.right);\n    }\n    BlockStmt(block: Stmt.BlockStmt) {\n        this.beginScope();\n        for (const stmt of block.statements) this.visit(stmt);\n        this.endScope();\n    }\n    CallExpr(expr: Expr.CallExpr) {\n        this.visit(expr.callee);\n        for (const arg of expr.args) this.visit(arg);\n    }\n    ExpressionStmt(stmt: Stmt.ExpressionStmt) {\n        this.visit(stmt.expr);\n    }\n    FunctionExpr(expr: Expr.FunctionExpr) {\n        this.resolveFunction(expr, FunctionType.FUNCTION);\n    }\n    FunctionDecl(decl: Decl.FunctionDecl) {\n        this.declare(decl.name);\n        this.define(decl.name);\n        this.resolveFunction(decl.func, FunctionType.FUNCTION);\n    }\n    GroupExpr(expr: Expr.GroupExpr) {\n        this.visit(expr.inner);\n    }\n    IfStmt(stmt: Stmt.IfStmt) {\n        this.visit(stmt.condition);\n        this.visit(stmt.trueStatement);\n        if (stmt.falseStatement) this.visit(stmt.falseStatement);\n    }\n    JumpStmt(stmt: Stmt.JumpStmt) {\n        this.visit(stmt.distance);\n    }\n    LiteralExpr(_expr: Expr.LiteralExpr) { }\n    LogicalExpr(expr: Expr.LogicalExpr) {\n        this.visit(expr.left);\n        this.visit(expr.right);\n    }\n    PrintStmt(stmt: Stmt.PrintStmt) {\n        this.visit(stmt.expr);\n    }\n    Program(program: Node.Program) {\n        for (const decl of program.code) this.visit(decl);\n    }\n    ReturnStmt(stmt: Stmt.ReturnStmt) {\n        if (this.currentFunction == FunctionType.NONE)\n            this.reporter.error(stmt.keyword, \"No return from top-level allowed\");\n        this.visit(stmt.expr);\n    }\n    TernaryExpr(expr: Expr.TernaryExpr) {\n        this.visit(expr.left);\n        this.visit(expr.middle);\n        this.visit(expr.right);\n    }\n    UnaryExpr(expr: Expr.UnaryExpr) {\n        this.visit(expr.operand);\n    }\n    VariableDecl(decl: Decl.VariableDecl) {\n        this.declare(decl.name);\n        if (decl.expr) {\n            this.visit(decl.expr);\n        }\n        this.define(decl.name);\n    }\n    VariableExpr(expr: Expr.VariableExpr) {\n        const scope = this.scopes[0];\n        if (!scope) return;\n        if (scope[expr.name.text] === VariableType.DECLARED)\n            this.reporter.error(expr.name, \"Reference to uninitialized variable\");\n        this.resolveLocal(expr, expr.name);\n    }\n    WhileStmt(stmt: Stmt.WhileStmt) {\n        this.visit(stmt.condition);\n        this.visit(stmt.body);\n    }\n}\n","import { RuntimeError } from 'stoa-ltk/runtime'\nimport { Token } from '../ast/nodes'\n\nexport class Environment {\n    constructor(readonly enclosure?: Environment) { }\n    private table = new Map<string, any>()\n    has(name: Token<'IDENTIFIER'>): boolean {\n        return this.table.has(name.text) || !!this.enclosure?.has(name)\n    }\n    init(name: Token<'IDENTIFIER'>) {\n        if (!this.table.has(name.text)) this.table.set(name.text, undefined)\n    }\n    set(name: Token<'IDENTIFIER'>, value: any, distance = 0): void {\n        if (distance > 0 && this.enclosure) return this.enclosure.set(name, value, distance - 1)\n        if (this.table.has(name.text)) this.table.set(name.text, value)\n        else if (this.enclosure?.has(name)) this.enclosure.set(name, value)\n        else throw new RuntimeError(name, `No such variable: ${name.text}`)\n    }\n    get<T = any>(name: Token<'IDENTIFIER'>, distance = 0): T {\n        if (distance > 0 && this.enclosure) return this.enclosure.get(name, distance - 1)\n        if (this.table.has(name.text)) return this.table.get(name.text)\n        if (this.enclosure?.has(name)) return this.enclosure.get(name)\n        throw new RuntimeError(name, `Undefined variable: ${name.text}`)\n    }\n}\n","import { Token } from \"../ast/nodes\"\nimport { Interpreter } from \"../interpreter\"\n\nexport function registerGlobals(evaluator: Interpreter) {\n    evaluator.globals.init({ text: \"clock\" } as Token<'IDENTIFIER'>)\n    evaluator.globals.set({ text: 'clock' } as Token<'IDENTIFIER'>, {\n        arity: 0, call() { return new Date().toLocaleString() }\n    })\n}\n","import { LiteralExpr } from '../ast/expressions'\nimport { Callable } from './control-flow'\n\nexport type Result = LiteralExpr['value'] | Callable\n\nexport function isNumber(val: unknown): val is [number, number] {\n    return Array.isArray(val) && val.length == 2\n}\n\nexport function isString(val: unknown): val is string {\n    return typeof val == 'string'\n}\n\nexport function truthy(val: unknown) {\n    if (val === false) return false\n    if (val === undefined) return false\n    return true\n}\n","import { Result } from './values'\n\nexport class ReturnException {\n    constructor(readonly value: Result = undefined) { }\n}\nexport class JumpException {\n    constructor(public distance = 1) { }\n}\nexport class BreakException extends JumpException { }\nexport class ContinueException extends JumpException { }\n\nexport interface Callable {\n    arity: number; call(args: Result[]): Result\n}\nexport function isCallable(val: Result): val is Callable {\n    if (!val) return false\n    return !!(val as Callable).call\n}\n\nexport class Function implements Callable {\n    constructor(\n        readonly arity: number,\n        readonly call: (args: Result[]) => Result\n    ) { }\n}\n","import { Reporter, RuntimeError } from \"stoa-ltk\";\nimport { Environment } from \"./runtime/environment\";\nimport { registerGlobals } from \"./runtime/globals\";\nimport { isNumber, isString, truthy, Result } from \"./runtime/values\";\nimport { BreakException, ContinueException, Function, isCallable, JumpException, ReturnException } from \"./runtime/control-flow\";\n\nimport { Visitor } from './ast/visitor'\nimport { TOKEN } from \"./ast/nodes\";\nimport * as Decl from './ast/declarations'\nimport * as Expr from './ast/expressions'\nimport * as Node from './ast/nodes'\nimport * as Stmt from './ast/statements'\n\n/**\n * Goals\n * 1) runtime error checking\n * 2) defer to runtime library for behavior\n */\n\nexport class Interpreter extends Visitor<Result> {\n    constructor(readonly reporter: Reporter) {\n        super()\n        registerGlobals(this)\n    }\n\n    readonly globals = new Environment()\n    private env = this.globals\n\n    locals: Map<Node.Expression, number> = new Map()\n    resolve(expr: Node.Expression, depth: number) {\n        this.locals.set(expr, depth)\n    }\n    lookUpVariable(name: Node.Token<'IDENTIFIER'>, expr: Node.Expression) {\n        const distance = this.locals.get(expr)\n        if (distance !== undefined) return this.env.get(name, distance)\n        return this.globals.get(name)\n    }\n\n    AssignExpr(expr: Expr.AssignExpr): Result {\n        const value = this.visit(expr.value)\n        const distance = this.locals.get(expr)\n        if (distance !== undefined) this.env.set(expr.name, value, distance)\n        else this.globals.set(expr.name, value)\n        return value\n    }\n    BinaryExpr(expr: Expr.BinaryExpr): Result {\n        const { operator: { name: op } } = expr\n        const left = this.visit(expr.left);\n        const right = this.visit(expr.right);\n        if (op == TOKEN.COMMA) return right;\n        if (op == TOKEN.PLUS) {\n            if (isString(left) || isString(right)) {\n                const lStr = (isCallable(left)) ? left : new Expr.LiteralExpr(left)\n                const rStr = (isCallable(right)) ? right : new Expr.LiteralExpr(right)\n                return `${lStr}${rStr}`\n            }\n        }\n        if (op == TOKEN.EQUAL_EQUAL) {\n            if (isNumber(left) && isNumber(right))\n                return left[0] == right[0]\n            else return left === right\n        }\n        if (op == TOKEN.BANG_EQUAL) {\n            if (isNumber(left) && isNumber(right))\n                return left[0] != right[0]\n            else return left !== right\n        }\n\n        if (!isNumber(left) || !isNumber(right))\n            throw new RuntimeError(expr.operator, \"number values expected\")\n        if (right[0] == 0) throw new RuntimeError(expr.operator, \"divide by zero\")\n        if (op == TOKEN.PLUS) return [left[0] + right[0], Math.max(left[1], right[1])];\n        if (op == TOKEN.DASH) return [left[0] - right[0], Math.max(left[1], right[1])];\n        if (op == TOKEN.STAR) return [left[0] * right[0], Math.max(left[1], right[1])];\n        if (op == TOKEN.SLASH) return [left[0] / right[0], Math.max(left[1], right[1])];\n        if (op == TOKEN.GREATER) return left[0] > right[0]\n        if (op == TOKEN.GREATER_EQUAL) return left[0] >= right[0]\n        if (op == TOKEN.LESS) return left[0] < right[0]\n        if (op == TOKEN.LESS_EQUAL) return left[0] <= right[0]\n        throw new RuntimeError(expr.operator, \"Unexpected binary expression\")\n    }\n    BlockStmt(block: Stmt.BlockStmt): Result {\n        const previous = this.env\n        this.env = new Environment(previous)\n        try {\n            block.statements.map(stmt => this.visit(stmt))\n        } finally {\n            this.env = previous\n        }\n    }\n    CallExpr(call: Expr.CallExpr): Result {\n        const callee = this.visit(call.callee)\n        if (!isCallable(callee)) throw new RuntimeError(call.end, \"uncallable target\")\n        if (callee.arity != call.args.length) throw new RuntimeError(call.end, \"wrong number of args\")\n        return callee.call(call.args.map(arg => this.visit(arg)))\n    }\n    ExpressionStmt(statement: Stmt.ExpressionStmt): void {\n        this.visit(statement.expr)\n    }\n    FunctionExpr(fun: Expr.FunctionExpr): Result {\n        const closure = new Environment(this.env)\n        return new Function(\n            fun.params.length,\n            (args: Result[]) => {\n                const previous = this.env\n                this.env = new Environment(closure)\n                try {\n                    args.map((arg, i) => {\n                        const param = fun.params[i]\n                        this.env.init(param)\n                        this.env.set(param, arg)\n                    })\n                    this.visit(fun.block)\n                } catch (e) {\n                    if (e instanceof ReturnException) {\n                        return e.value\n                    } else throw e\n                } finally {\n                    this.env = previous\n                }\n            })\n    }\n    FunctionDecl(decl: Decl.FunctionDecl): Result {\n        const func = this.FunctionExpr(decl.func)\n        this.env.init(decl.name)\n        this.env.set(decl.name, func)\n    }\n    GroupExpr(expr: Expr.GroupExpr): Result {\n        return this.visit(expr.inner);\n    }\n    IfStmt(statement: Stmt.IfStmt): Result {\n        const condition = this.visit(statement.condition);\n        if (truthy(condition)) this.visit(statement.trueStatement);\n        else if (statement.falseStatement) this.visit(statement.falseStatement);\n    }\n    JumpStmt(stmt: Stmt.JumpStmt): Result {\n        const distance = this.visit(stmt.distance || new Expr.LiteralExpr([1, 0]))\n        if (!isNumber(distance))\n            throw new RuntimeError(stmt.keyword, \"expected numerical distance\")\n        throw stmt.keyword.name == TOKEN.BREAK\n            ? new BreakException(distance[0])\n            : new ContinueException(distance[0])\n    }\n    LiteralExpr(expr: Expr.LiteralExpr): Result {\n        return expr.value\n    }\n    LogicalExpr(expr: Expr.LogicalExpr): Result {\n        const { operator: { name: op } } = expr\n        const left = this.visit(expr.left)\n        const left_truthy = truthy(left)\n        if (op == TOKEN.OR && left_truthy) return left\n        if (op == TOKEN.AND && !left_truthy) return left\n        const right = this.visit(expr.right)\n        if (truthy(right)) return right\n        return truthy(false)\n    }\n    PrintStmt(statement: Stmt.PrintStmt): void {\n        const val = this.visit(statement.expr)\n        const str = (isCallable(val)) ? val : new Expr.LiteralExpr(val).toString()\n        console.log(str + '')\n    }\n    Program(program: Node.Program): Result {\n        try {\n            const statements = program.code.map(stmt => this.visit(stmt))\n            const last = statements[statements.length - 1]\n            if (isCallable(last)) return `${last}`\n            return new Expr.LiteralExpr(last).toString()\n        } catch (e) {\n            if (!(e instanceof RuntimeError)) {\n                // need some token?\n                // @ts-expect-error\n                this.reporter.error(undefined, (e as Error).message)\n            } else {\n                this.reporter.error(e.token, e.message)\n            }\n        }\n    }\n    ReturnStmt(ret: Stmt.ReturnStmt): Result {\n        const value = this.visit(ret.expr)\n        throw new ReturnException(value)\n    }\n    TernaryExpr(expr: Expr.TernaryExpr): Result {\n        const { op1: { name: op1 }, op2: { name: op2 } } = expr\n        if (op1 == TOKEN.QUESTION && op2 == TOKEN.COLON) {\n            const left = this.visit(expr.left);\n            if (truthy(left)) return this.visit(expr.middle);\n            return this.visit(expr.right);\n        }\n        throw new RuntimeError(op1, \"Unexpected ternary expression\")\n    }\n    UnaryExpr(expr: Expr.UnaryExpr): Result {\n        const { operator: { name: op } } = expr\n        const value = this.visit(expr.operand);\n        if (op == TOKEN.BANG) return !truthy(value);\n        if (!isNumber(value)) throw new RuntimeError(op, \"must negate a number value\")\n        if (op == TOKEN.DASH) return [-value[0], value[1]];\n        throw new RuntimeError(op, \"Unexpected unary expression\")\n    }\n    VariableDecl(declaration: Decl.VariableDecl): Result {\n        this.env.init(declaration.name)\n        const val = declaration.expr ? this.visit(declaration.expr) : undefined\n        this.env.set(declaration.name, val)\n    }\n    VariableExpr(expr: Expr.VariableExpr): Result {\n        return this.lookUpVariable(expr.name, expr)\n    }\n    WhileStmt(statement: Stmt.WhileStmt): Result {\n        while (truthy(this.visit(statement.condition))) {\n            try {\n                this.visit(statement.body)\n            } catch (e) {\n                if (e instanceof JumpException) {\n                    if (e.distance > 1) {\n                        e.distance -= 1\n                        throw e\n                    }\n                    if (e instanceof ContinueException) continue\n                    if (e instanceof BreakException) break\n                }\n            }\n        }\n    }\n}\n","import { Language } from \"stoa-ltk\";\nimport { version } from \"../../package.json\";\nimport { Ast } from \"./ast/nodes\";\nimport { Tokenizer, Lexicon } from \"./tokenizer\";\nimport { Parser } from \"./parser\";\nimport { Resolver } from \"./resolver\";\nimport { Interpreter } from \"./interpreter\";\nimport { Result } from \"./runtime/values\";\n\nexport class StoxLang extends Language<Lexicon, Ast, Result> {\n\n    readonly version = version\n    Tokenizer = Tokenizer;\n    Parser = Parser;\n    Resolver = Resolver;\n    Interpreter = Interpreter;\n}\n","export class Repl {\n    constructor(readonly lang: any) { }\n    async run() {\n        return new Promise(resolve => resolve(undefined))\n    }\n}\n","import * as Rpk from \"repl-kit\";\nexport class Repl extends Rpk.Repl { }\n\n// @ ts-expect-error this project kinda sucks like this\n// import { AutoComplete } from 'enquirer'\n// import * as Lib from \"./lib\";\n// import UI from 'readline-ui'\n// import chalk from 'chalk'\n// import { Driver } from \".\"\n\n// export class Repl {\n//   constructor(readonly lang: Lib.Language<any, any, any>) { }\n//   async run() {\n//     const prompt = new AutoComplete({\n//       name: 'flavor',\n//       message: 'Pick your favorite flavor',\n//       limit: 10,\n//       initial: 2,\n//       choices: [\n//         'Almond',\n//         'Apple',\n//         'Banana',\n//         'Blackberry',\n//         'Blueberry',\n//         'Cherry',\n//         'Chocolate',\n//         'Cinnamon',\n//         'Coconut',\n//         'Cranberry',\n//         'Grape',\n//         'Nougat',\n//         'Orange',\n//         'Pear',\n//         'Pineapple',\n//         'Raspberry',\n//         'Strawberry',\n//         'Vanilla',\n//         'Watermelon',\n//         'Wintergreen'\n//       ]\n//     });\n\n//     return prompt.run()\n//   }\n//   async run2() {\n//     console.log(\"in the repl\");\n\n//     var stdin = process.stdin;\n//     stdin.setRawMode(true);\n//     stdin.setEncoding(\"utf8\");\n\n//     let line = \"\";\n\n//     return new Promise((resolve) => {\n//       stdin.on(\"data\", (key) => {\n//         // console.log({ key });\n//         if ([\"\\x1A\", \"\\x03\", \"\\x04\"].includes(key.toString())) {\n//           // CTRL-c, CTRL-d\n//           stdin.destroy();\n//           resolve(undefined);\n//         }\n//         if (!key.toString().match(/[\\p{Cc}\\p{Cn}\\p{Cs}]+/gu)) {\n//           line += key.toString();\n//           process.stdout.write(key);\n//         }\n//         if ([\"\\x7F\"].includes(key.toString())) {\n//           line = line.substring(0, line.length - 2);\n//           // process.stdout.clearLine(0);\n//           // process.stdout.write(line);\n//           process.stdout.write(\"\\x08\");\n//         }\n//         if ([\"\\r\", \"\\n\"].includes(key.toString())) {\n//           console.log(\"running line:\", line);\n//           this.lang.run(\"repl\", line);\n//           line = \"\";\n//         }\n//       });\n//     });\n//   }\n// }\n\n// function red(strings: TemplateStringsArray) {\n//     return `\\x1b[31m${strings.join('')}\\x1b[0m`\n// }\n// function blue(strings: TemplateStringsArray) {\n//     return `\\x1b[34m${strings.join('')}\\x1b[0m`\n// }\n// function green(strings: TemplateStringsArray) {\n//     return `\\x1b[32m${strings.join('')}\\x1b[0m`\n// }\n"],"mappings":"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","names":[]}