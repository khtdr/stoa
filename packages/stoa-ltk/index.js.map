{"version":3,"sources":["../../lib/stoa-ltk/index.ts","../../lib/stoa-ltk/language.ts","../../lib/stoa-ltk/tokenizer.ts","../../lib/stoa-ltk/parser.ts","../../lib/stoa-ltk/reporter.ts","../../lib/stoa-ltk/runtime.ts"],"sourcesContent":["// export * from \"./cli\";\nexport * from \"./language\";\nexport * from \"./tokenizer\";\nexport * from \"./parser\";\n// export * from \"./repl\";\nexport * from \"./reporter\";\nexport * from \"./runtime\";\n","import * as Lib from '.'\n\ntype RuntimeOpts = { stage: \"scan\" | \"parse\" | \"eval\" };\n\nexport abstract class Language<Tokens extends Lib.Lexicon, Ast extends object, Result> {\n    abstract readonly Tokenizer: typeof Lib.TokenStreamClass<Tokens>;\n    abstract readonly Parser: typeof Lib.Parser<Tokens, Ast>;\n    abstract readonly Resolver: typeof Lib.Visitor<Ast, void>;\n    abstract readonly Interpreter: typeof Lib.Visitor<Ast, Result>;\n    constructor(readonly reporter: Lib.Reporter = new Lib.StdErrReporter()) { }\n\n    private _interpreter?: Lib.Visitor<Ast, Result>\n    get interpreter() {\n        if (!this._interpreter)\n            this._interpreter = new this.Interpreter(this.reporter)\n        return this._interpreter\n    }\n\n    private _resolver?: Lib.Visitor<Ast, void>\n    get resolver() {\n        if (!this._resolver)\n            this._resolver = new this.Resolver(this.reporter, this.interpreter)\n        return this._resolver\n    }\n\n    private opts: RuntimeOpts = { stage: \"eval\" };\n    options(opts: RuntimeOpts) {\n        this.opts = opts;\n    }\n\n    public errored = false;\n    run(name: string, code: string) {\n        this.errored = false;\n        this.reporter.pushSource(name, code);\n        this.runToStage(code);\n        this.reporter.popSource();\n    }\n\n    private runToStage(source: string) {\n        const scanner = new this.Tokenizer(source, this.reporter);\n        const tokens = scanner.drain();\n        if (this.reporter.errors) {\n            this.errored = true;\n            this.reporter.tokenError();\n        }\n\n        if (this.opts.stage === \"scan\") {\n            scanner.print(tokens)\n            return;\n        }\n\n        const parser = new this.Parser(tokens, this.reporter);\n        const ast = parser.parse();\n        if (this.reporter.errors) {\n            this.errored = true;\n            this.reporter.parseError();\n            return;\n        }\n\n        if (!ast) return\n\n        this.resolver.visit(ast);\n        if (this.reporter.errors) {\n            this.errored = true;\n            this.reporter.parseError();\n            return;\n        }\n\n        if (this.opts.stage == \"parse\") {\n            parser.print(ast)\n            return;\n        }\n\n        if (this.errored) {\n            return\n        }\n\n        this.interpreter.visit(ast);\n        if (this.reporter.errors) {\n            this.errored = true;\n            this.reporter.runtimeError();\n        }\n    }\n}\n","import * as Lib from \".\";\n\nexport type Lexeme =\n    | string\n    | RegExp\n    | ((\n        text: string,\n        reporter: Lib.Reporter,\n        line: number,\n        column: number\n    ) => undefined | string);\nexport type Lexicon = Record<string, Lexeme>;\nconst ERROR_TOKEN = \"__stoa__::error\";\n\nexport class Token<Name = string> {\n    constructor(\n        readonly name: Name,\n        readonly text: string,\n        readonly pos: { line: number; column: number }\n    ) { }\n    toString() {\n        const pos = `[${this.pos.line},${this.pos.column}]`;\n        return `${this.name}${pos}`;\n    }\n}\n\nexport class TokenStream<Lx extends Lexicon> {\n    private generator: Generator<Token<keyof Lx>>;\n    constructor(\n        source: string,\n        lexicon: Lx,\n        readonly reporter: Lib.Reporter,\n        line = 1,\n        column = 1\n    ) {\n        this.generator = tokenGenerator(source, lexicon, reporter, line, column);\n    }\n\n    private buffer: (Token<keyof Lx> | undefined)[] = [];\n    take(): Token<keyof Lx> | undefined {\n        this.peek();\n        return this.buffer.shift();\n    }\n    peek(): Token<keyof Lx> | undefined {\n        if (!this.buffer.length) this.buffer.push(this.next());\n        return this.buffer[0];\n    }\n    drain(): Token<keyof Lx>[] {\n        let token,\n            tokens = [];\n        while ((token = this.take())) tokens.push(token);\n        return tokens;\n    }\n    print(tokens = this.buffer, level: \"error\" | \"log\" = \"log\") {\n        console[level](tokens.map((t) => `${t}`).join(\"\\n\"));\n    }\n\n    private eof = false;\n    private next(): Token<keyof Lx> | undefined {\n        while (true) {\n            if (this.eof) return;\n            const token = this.generator.next().value;\n            if (!token) {\n                this.eof = true;\n                continue;\n            }\n            if (token.name == ERROR_TOKEN) {\n                this.reporter.error(token, `Unrecognized input`);\n                continue;\n            }\n            if (token.name.toString().startsWith(\"_\")) {\n                continue;\n            }\n            return token;\n        }\n    }\n}\n\nexport class TokenStreamClass<Lx extends Lexicon> extends TokenStream<Lx> {\n    constructor(source: string, reporter: Lib.Reporter) {\n        super(source, {} as Lx, reporter);\n    }\n}\n\nfunction* tokenGenerator<Lx extends Lexicon>(\n    source: string,\n    lexicon: Lx,\n    reporter: Lib.Reporter,\n    start_line: number,\n    start_column: number\n): Generator<Token<keyof Lx>> {\n    let idx = 0,\n        line = start_line,\n        column = start_column;\n    while (idx < source.length) {\n        const [name = ERROR_TOKEN, text = source[idx]] = longest(possible());\n        const token = new Token(name, text, pos());\n\n        const lines = text.split(\"\\n\").length;\n        if (lines > 1) {\n            line += lines - 1;\n            column = text.length - text.lastIndexOf(\"\\n\");\n        } else column += text.length;\n        idx += text.length;\n        yield token;\n    }\n\n    function pos() {\n        return { line: line, column: column };\n    }\n    function longest(candidates: [keyof Lx, string, boolean][]) {\n        if (!candidates.length) return [];\n        if (candidates.length == 1) return candidates[0];\n        return candidates.reduce((longest, current) => {\n            if (current[1].length > longest[1].length) return current;\n            if (current[1].length == longest[1].length)\n                return !current[2] && longest[2] ? current : longest;\n            return longest;\n        });\n    }\n    function possible() {\n        const candidates: [keyof Lx, string, boolean][] = [];\n        Object.entries(lexicon).map(([name, rule]) => {\n            if (typeof rule == \"function\") {\n                const text = rule(source.substring(idx), reporter, line, column);\n                if (text !== undefined) candidates.push([name, text, false]);\n            } else if (typeof rule != \"string\") {\n                const dynamic = rule.source[rule.source.length - 1] == \"*\";\n                const regex = new RegExp(`^${rule.source}`, rule.flags);\n                const match = regex.exec(source.substring(idx));\n                if (match) return candidates.push([name, match[0], dynamic]);\n            } else if (source.substring(idx, idx + rule.length) == rule) {\n                return candidates.push([name, rule, false]);\n            }\n        });\n        return candidates;\n    }\n}\n\nexport const Tokens = {\n    STRINGS: {\n        STD: stringScanner,\n    },\n    COMMENTS: {\n        SHEBANG: /\\#\\!\\/usr\\/bin\\/env\\s.*/,\n        DOUBLE_SLASH: /\\/\\/.*/,\n        C_STYLE: cStyleCommentScanner,\n    },\n    SPACE: {\n        ALL: /\\s+/,\n    },\n};\n\nfunction cStyleCommentScanner(\n    value: string,\n    reporter: Lib.Reporter,\n    line: number,\n    column: number\n) {\n    const tokenizer = new TokenStream(\n        value,\n        {\n            OPEN: \"/*\",\n            CLOSE: \"*/\",\n            ESCAPED_CHAR: /\\\\./,\n            CHAR: /.|\\s/,\n        },\n        reporter,\n        line,\n        column\n    );\n    const opener = tokenizer.take();\n    if (opener && opener.name == \"OPEN\") {\n        let stack = 0,\n            closer: Lib.Token | undefined,\n            text = opener.text;\n        while ((closer = tokenizer.take())) {\n            text += closer.text;\n            if (closer.name == \"OPEN\") stack += 1;\n            else if (closer.name == \"CLOSE\") {\n                if (!stack) return text;\n                else stack -= 1;\n            }\n        }\n        reporter.error(opener, `Unclosed comment`);\n        return text;\n    }\n}\n\nfunction stringScanner(\n    value: string,\n    reporter: Lib.Reporter,\n    line: number,\n    column: number\n) {\n    const tokenizer = new Lib.TokenStream(\n        value,\n        {\n            SINGLE: \"'\",\n            DOUBLE: '\"',\n            ESCAPED_CHAR: /\\\\./,\n            CHAR: /.|\\s/,\n        },\n        reporter,\n        line,\n        column\n    );\n    const opener = tokenizer.take();\n    if (opener && [\"SINGLE\", \"DOUBLE\"].includes(opener.name)) {\n        let { text } = opener,\n            closer: Lib.Token | undefined;\n        while ((closer = tokenizer.take())) {\n            text += closer.text;\n            if (closer.name == opener.name) return text;\n        }\n        reporter.error(opener, `Unclosed string, expected ${opener.text}`);\n        return text;\n    }\n}\n","import * as Lib from \".\";\n\nexport class Parser<Lx extends Lib.Lexicon, Ast extends object> {\n  constructor(\n    private readonly tokens: Lib.Token<keyof Lx>[],\n    protected reporter: Lib.Reporter\n  ) {}\n\n  parse(): Ast | undefined {\n    return undefined;\n  }\n  print(ast?: Ast, level: \"error\" | \"log\" = \"log\") {\n    console[level](`${ast ?? \"\"}`);\n  }\n\n  private current = 0;\n\n  protected match(...names: string[]): boolean {\n    for (const name of names) {\n      if (this.check(name)) {\n        this.advance();\n        return true;\n      }\n    }\n    return false;\n  }\n\n  protected consume<Name extends keyof Lx>(\n    name: Name,\n    message: string\n  ): Lib.Token<Name> {\n    if (this.check(name)) return this.advance() as Lib.Token<typeof name>;\n    throw this.error(message);\n  }\n\n  protected error(message: string, token?: Lib.Token<any>) {\n    let tk: Lib.Token<any> = token || this.peek() || this.previous();\n    let error = new InvalidParseTree(message);\n    if (!this.peek()) {\n      const lines = tk.text.split(\"\\n\");\n      const addLines = lines.length - 1;\n      const line = tk.pos.line + addLines;\n      const column = addLines\n        ? lines[lines.length - 1].length + 1\n        : tk.pos.column + tk.text.length;\n      tk = new Lib.Token(\"<EOF>\", \"\", { line, column });\n      error = new IncompleteParseTree(message);\n    }\n    this.reporter.error(tk, message);\n    return error;\n  }\n\n  protected check(name: keyof Lx): boolean {\n    return this.peek()?.name == name;\n  }\n\n  protected atEnd(): boolean {\n    return !this.peek()?.name;\n  }\n\n  protected advance(): Lib.Token<keyof Lx> {\n    if (!this.atEnd()) this.current++;\n    return this.previous();\n  }\n\n  protected peek(ahead = 1): Lib.Token<keyof Lx> | undefined {\n    return this.tokens[this.current + (ahead - 1)];\n  }\n\n  protected previous<Name extends keyof Lx = keyof Lx>(): Lib.Token<Name> {\n    return this.tokens[this.current - 1] as Lib.Token<Name>;\n  }\n}\n\nexport class Visitor<Ast extends object, Result = string> {\n  constructor(\n    readonly reporter: Lib.Reporter = new Lib.StdErrReporter(),\n    readonly interpreter?: any\n  ) {}\n  visit(node: Ast): Result {\n    const name = node.constructor.name;\n    const fn = this[name as keyof this];\n    if (typeof fn == \"function\") return fn.bind(this)(node);\n    throw new Error(`Unvisitable node: ${name} (UNIMPLEMENTED BY AUTHOR)`);\n  }\n}\n\nexport class ParseError extends Error {}\n// TODO the repl can use these to quit an input vs prompt more lines\nexport class InvalidParseTree extends ParseError {}\nexport class IncompleteParseTree extends ParseError {}\n","import { Token } from \".\";\n\ntype Errors = [Token, string][]\n\nexport interface Reporter {\n    error(token: Token, message?: string): void\n    pushSource(name: string, source: string): void\n    popSource(): void\n    tokenError(): void\n    parseError(): void\n    runtimeError(): void\n    errors: false | [Token, string][]\n}\n\nexport class StdErrReporter implements Reporter {\n    private files: [string, string][] = []\n    pushSource(name: string, source: string) {\n        this.files.push([name, source])\n    }\n    popSource() {\n        this.files.pop()\n    }\n\n    private _errors: Errors = []\n    error(token: Token, message: string) {\n        this._errors.push([token, message])\n    }\n    get errors(): false | Errors {\n        return !this._errors.length ? false : this._errors\n    }\n\n    tokenError() { this.reportErrors('Syntax') }\n    parseError() { this.reportErrors('Parse') }\n    runtimeError() { this.reportErrors('Runtime') }\n    private reportErrors(type: string) {\n        const [name, source] = this.files[this.files.length - 1]\n        const lines = source.split(\"\\n\")\n        for (const [token, message] of this._errors) {\n            this.log(`${type} error in ${name} at line,col ${token.pos.line},${token.pos.column}`)\n            const prefix = `${token.pos.line}. `\n            const code = `${lines[token.pos.line - 1]}`\n            this.log(`${prefix}${code}`)\n            const spaces = `${prefix}${code}`.replace(/./g, ' ')\n            const arr = spaces.substring(0, prefix.length + token.pos.column - 1)\n            this.log(`${arr}↑`)\n            this.log(`${message}`)\n        }\n        this._errors = []\n    }\n\n    protected log(message: string) {\n        console.error(message)\n    }\n}\n","import { Token } from \"./tokenizer\";\n\nexport class RuntimeError extends Error {\n    constructor(readonly token: Token, message: string) {\n        super(message)\n    }\n}\n"],"mappings":"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","names":[]}