#+TITLE: stoa stage-0
#+AUTHOR: Oh Kay


* [ ] Stage-0 Goals:
** [X] basic language design
** [X] language essentials
*** [X] lexer/tokenizer
*** [X] scanner/parser
*** [X] interpreter
** [X] language tools
*** [X] command line interface
**** [X] tokenizng and parsing options
**** [X] basic colorful repl
**** [X] read from piped stdin 
*** [X] emacs integration
**** [X] syntax highlighting
**** [X] org-mode code blocks
** [X] lots of tests
** [X] build system
** [ ] website with runnable code
*** [ ] readme writeup
*** [ ] stoa web component


* Language Design
** Look and feel of Stoa
Instead of finding myself lost in the possibilities, I will pick
a starting point. And that starting point is obviously Lisp.

And not some fancy lisp, just =(operator ...operands)=

I know I can make that work, I'll just spice it up a bit. Add in some
conventions, remove a lot of flexibility. Remove as many features as
needed to get through the goals of Stage 0.

*TLDR; .elisp -> .stoa**
An interative factorial function written in elisp:
#+BEGIN_SRC elisp
(defun factorial (num)
  (setq idx 1)
  (setq product 1)
  (while (< idx num)
      (setq idx (+ idx 1))
      (setq product (* product idx)))
   product)
 (factorial 3)
#+END_SRC

With some shake-up becomes stoa code:
#+BEGIN_SRC stoa
=>(factorial num :
  <-(product 1)
  # (idx 1 num
      <-(product *(product idx))))
factorial(3)
#+END_SRC

*** Data Types
Do you remember the part about removing features? Here we go.

There are only numbers.
No strings, no booleans, no lists, no maps, no floats, just integers.

(But technically...)
- *integers* ~... -1 0 1 2 ... 99 100 101 ...~
  Whole numbers, no decimals
  
- *function names*  ~"factorial"~
  Displayed as a name in double quotes 
  
- *undefined*  ~undefined~
  Everything else?

#+BEGIN_SRC elisp
(defun factorial (n)
   (if (= n 0) 1
       (* n (factorial (- n 1)))))
#+END_SRC

Moving the parens inwards, and replacing the keywords with symbols gives:
#+BEGIN_SRC stoa
=>(factorial n
 ?(=(n 0) 1
    *(n factorial( -(n 1) ))))
#+END_SRC


Likewise, the iterative version:



** Grammar
#+BEGIN_SRC ebnf
program    = expr* END
expr       = term-list|term
term-list  = ':' expr+ ('.'|')'|END))?
term       = callable|scalar
callable   = call|assignment|flow|operator
call       = identifier '(' args ')'
assignment = variable|function
variable   = '<-' '(' identifier expr ')'
function   = '=>' '(' identifier identifier* expr ')'
operator   = (op-comp|op-math|op-builtin) "(" args ")"
op-comp    = '='|'<'|'>'
op-math    = '+'|'-'|'*'|'/'
op-builtin = '~~'
flow       = flow-if|flow-for
flow-if    = '?' '(' expr expr expr? ')'
flow-for   = '#' '(' identifier expr expr expr ')'
args       = expr*
scalar     = identifier|digits
digits     = /^\d+/
identifier = /^\w[\w\d]*/
END        = (* End Of Input *)
#+END_SRC

* potentially more
** Basic Types
- true false       =boolean=
- 1 2 3 4 12,345   =integer=
- 1.0 1,200,433.65 =float=
- "string"         =string=
- variable-name    =reference=

** Structure Types
*** Lists [...]
[1 2 3]
[:a :b :c "abc" [1 2 3]]
*** Maps {...}
{"key1" "value1" 4 2}
*** Sets <...>
<"key1" "value1" 4 2>

** Function Calls
variable-name(arg1 arg2 arg3)

** Assignment
pi -> 3.14
3.14 <- pi
([args], body)

** Examples
factorial -> ( n
  if( =(n 0) 1
    *(n factorial( -(n 1) ))))
